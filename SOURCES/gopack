#!/usr/bin/env bash

########################################################################################

APP="gopack"
VER="1.2.0"

########################################################################################

NORM=0
BOLD=1
UNLN=4
RED=31
GREEN=32
BROWN=33
BLUE=34
MAG=35
CYAN=36
GREY=37
DARK=90

CL_NORM="\e[${NORM}m"
CL_BOLD="\e[${BOLD}m"
CL_UNLN="\e[${UNLN}m"
CL_RED="\e[${RED}m"
CL_GREEN="\e[${GREEN}m"
CL_BROWN="\e[${BROWN}m"
CL_BLUE="\e[${BLUE}m"
CL_MAG="\e[${MAG}m"
CL_CYAN="\e[${CYAN}m"
CL_GREY="\e[${GREY}m"
CL_DARK="\e[${DARK}m"
CL_BL_RED="\e[${RED};1m"
CL_BL_GREEN="\e[${GREEN};1m"
CL_BL_BROWN="\e[${BROWN};1m"
CL_BL_BLUE="\e[${BLUE};1m"
CL_BL_MAG="\e[${MAG};1m"
CL_BL_CYAN="\e[${CYAN};1m"
CL_BL_GREY="\e[${GREY};1m"
CL_BL_DARK="\e[${DARK};1m"
CL_UL_RED="\e[${RED};4m"
CL_UL_GREEN="\e[${GREEN};4m"
CL_UL_BROWN="\e[${BROWN};4m"
CL_UL_BLUE="\e[${BLUE};4m"
CL_UL_MAG="\e[${MAG};4m"
CL_UL_CYAN="\e[${CYAN};4m"
CL_UL_GREY="\e[${GREY};4m"
CL_UL_DARK="\e[${DARK};4m"
CL_BG_RED="\e[${RED};7m"
CL_BG_GREEN="\e[${GREEN};7m"
CL_BG_BROWN="\e[${BROWN};7m"
CL_BG_BLUE="\e[${BLUE};7m"
CL_BG_MAG="\e[${MAG};7m"
CL_BG_CYAN="\e[${CYAN};7m"
CL_BG_GREY="\e[${GREY};7m"
CL_BG_DARK="\e[${DARK};7m"

########################################################################################

SEPARATOR="--------------------------------------------------------------------------------"

TMP_TEMPLATE="gopack-XXXXXXXX"

SUPPORTED_ARCH_TYPES="tbz2 tar.bz2 tgz tar.gz tbz tar.bz"

SUPPORTED_ARGS="tmp output version revision tag branch !no_colors !verbose !help 
 !usage !about"
SHORT_ARGS="T:tmp o:output v:version r:revision t:tag b:branch nc:!no_colors 
 V:!verbose h:!help"

# Path to temporary dir (String)
tmp="/tmp"

########################################################################################

# Main function
#
# *: All unparsed argumens
#
# Code: No
# Echo: No
main() {
  if [[ ! -t 1 || -n "$no_colors" ]] ; then
    unset NORM BOLD UNLN RED GREEN BROWN BLUE MAG CYAN GREY DARK
    unset CL_NORM CL_BOLD CL_UNLN CL_RED CL_GREEN CL_BROWN CL_BLUE CL_MAG CL_CYAN CL_GREY CL_DARK
    unset CL_BL_RED CL_BL_GREEN CL_BL_BROWN CL_BL_BLUE CL_BL_MAG CL_BL_CYAN CL_BL_GREY CL_BL_DARK
    unset CL_UL_RED CL_UL_GREEN CL_UL_BROWN CL_UL_BLUE CL_UL_MAG CL_UL_CYAN CL_UL_GREY CL_UL_DARK
    unset CL_BG_RED CL_BG_GREEN CL_BG_BROWN CL_BG_BLUE CL_BG_MAG CL_BG_CYAN CL_BG_GREY CL_BG_DARK
  fi

  if [[ -n "$about" ]] ; then
    about
    exit 0
  fi

  if [[ -n "$help" || -n "$usage" || $# -eq 0 ]] ; then
    usage
    exit 0
  fi

  if [[ -z "$tmp" ]] ; then
    show "Path to temporary directory can't be empty" $RED
    exit 1
  fi

  if [[ ! -d "$tmp" ]] ; then
    show "${CL_RED}Temporary directory ${CL_BL_RED}${tmp}${CL_RED} is not exist${CL_NORM}"
    exit 1
  fi

  if [[ ! -w "$tmp" || ! -r "$tmp" || ! -x "$tmp" ]] ; then
    show "${CL_RED}Temporary directory ${CL_BL_RED}${tmp}${CL_RED} must be readable, writable and executable${CL_NORM}"
    exit 1
  fi

  if [[ ! $(type -P go) ]] ; then
    show "This utility require go. Install it first." $RED
    exit 1
  fi

  process "$1"
}

# Download and pack sources
#
# 1: Path (String)
#
# Code: No
# Echo: No
process() {
  local package tmp_dir arch_name

  package="$1"
  tmp_dir=$(mktemp -d "${tmp:?}/$TMP_TEMPLATE")

  if [[ -z "$output" ]] ; then
    output=$(getOutputName "$package")
  fi

  showm "Setting temporary Go environment variables... " $BOLD

  setupGoEnv "$tmp_dir"

  show "DONE" $GREEN

  if ! checkoutCode "$package" "$tmp_dir" ; then
    cleanAndExit "$tmp_dir" 1
  fi

  if ! downloadDeps "$package" "$tmp_dir" ; then
    cleanAndExit "$tmp_dir" 1
  fi

  arch_name=$(getArchName "$output")

  mv "${tmp_dir}/src" "${tmp_dir}/${arch_name}"
  mv "${tmp_dir}/REVISIONS" "${tmp_dir}/${arch_name}/"

  if ! packSources "$output" "$tmp_dir" ; then
    cleanAndExit "$tmp_dir" 1
  fi

  cp "${tmp_dir}/${output}" .

  [[ -z "$verbose" ]] && show ""

  show "${CL_GREEN}Sources packed and saved as ${CL_BL_GREEN}${output}${CL_NORM}"

  cleanAndExit "$tmp_dir"
}

# Make directory for go sources and set GOPATH environment variable
#
# Code: No
# Echo: No
setupGoEnv() {
  local tmp_dir="$1"

  mkdir "$tmp_dir/src"
  mkdir "$tmp_dir/pkg"
  mkdir "$tmp_dir/bin"

  export GOPATH="$tmp_dir"
}

# Checkout source code
#
# 1: Path to temporary dir (String)
# 2: Path to source code (String)
#
# Code: No
# Echo: No
checkoutCode() {
  local package tmp_dir git_path package_name

  package="$1"
  tmp_dir="$2"
  git_path="https://$package.git"
  package_name=$(basename "$package")

  showm "Downloading sources... " $BOLD

  if ! httpStatusOk "$git_path" ; then
    show "ERROR" $RED
    show "${CL_RED}Repository ${CL_BL_RED}${git_path}${CL_RED} is not accessible${CL_NORM}"
    return 1
  fi

  mkdir -p "$tmp_dir/src/$package"

  if ! execCmd "git" "clone" "$git_path" "$tmp_dir/src/$package/" ; then
    show "${CL_RED}Error while cloning repository ${CL_BL_RED}${git_path}${CL_NORM}" $RED
    return 1
  fi

  pushd "$tmp_dir/src/$package" &> /dev/null

    if [[ -n "$revision" ]] ; then
      showm "Switching HEAD to revision $revision... " $BOLD

      if ! execCmd "git" "checkout" "$revision" ; then
        show "${CL_RED}Can't checkout revision ${CL_BL_RED}${revision}${CL_NORM}" $RED
        return 1
      fi
    fi

    if [[ -n "$branch" ]] ; then
      showm "Switching HEAD to branch $branch... " $BOLD

      if ! execCmd "git" "checkout" "$branch" ; then
        show "${CL_RED}Can't checkout branch ${CL_BL_RED}${branch}${CL_NORM}" $RED
        return 1
      fi
    fi

    if [[ -n "$tag" ]] ; then
      showm "Switching HEAD to tag $tag... " $BOLD

      if ! execCmd "git" "checkout" "$tag" ; then
        show "${CL_RED}Can't checkout tag ${CL_BL_RED}${tag}${CL_NORM}" $RED
        return 1
      fi
    fi

  popd &> /dev/null

  return 0
}

# Download dependencies for given package
#
# 1: Package name (String)
# 2: Path to temporary directory with sources (String)
#
# Code: Yes
# Echo: No
downloadDeps() {
  local package tmp_dir

  package="$1"
  tmp_dir="$2"

  showm "Downloading dependencies... " $BOLD

  pushd "$tmp_dir/src/$package" &> /dev/null

    if ! execCmd "go" "get" "-d" "-v" "./..." ; then
      show "Can't download package dependencies" $RED
      return 1
    fi

  popd &> /dev/null

  saveLatestCommitsHash "${tmp_dir}/src" "${tmp_dir}/REVISIONS"
  cleanPackDir "${tmp_dir}/src"

  return 0
}

# Save latest commit hash to file (currently supported only git)
#
# 1: Path to dir with sources (String)
# 2: Output file (String)
#
# Code: No
# Echo: No
saveLatestCommitsHash() {
  local dir output git_dir repo_dir head_hash

  dir="$1"
  output="$2"

  pushd "$dir" &> /dev/null

    for git_dir in $(find . -name ".git" -type d) ; do

      pushd "$git_dir" &> /dev/null

        pushd .. &> /dev/null

          repo_dir=$(dirname "${git_dir:2:9999}")
          head_hash=$(git rev-parse HEAD)

        popd &> /dev/null

        echo "$head_hash $repo_dir" >> "$output"

      popd &> /dev/null

    done

  popd &> /dev/null
}

# Remove repo data and CI services configs
#
# 1: Path to directory with sources (String)
#
# Code: No
# Echo: No
cleanPackDir() {
  local dir="$1"

  find "$dir" -type d -name ".git" -exec rm -rf {} \; 2> /dev/null
  find "$dir" -type f -name ".gitignore" -exec rm -f {} \; 2> /dev/null
  find "$dir" -type f -name ".gitattributes" -exec rm -f {} \; 2> /dev/null
  find "$dir" -type f -name ".gitmodules" -exec rm -f {} \; 2> /dev/null
  find "$dir" -type f -name ".travis.yml" -exec rm -f {} \; 2> /dev/null
  find "$dir" -type f -name ".drone.sec" -exec rm -f {} \; 2> /dev/null
  find "$dir" -type f -name ".drone.yml" -exec rm -f {} \; 2> /dev/null
  find "$dir" -type f -name ".hound.yml" -exec rm -f {} \; 2> /dev/null
  find "$dir" -type f -name ".vexor.yml" -exec rm -f {} \; 2> /dev/null
  find "$dir" -type f -name ".codebeatsettings" -exec rm -f {} \; 2> /dev/null
}

# Pack source into archive
#
# 1: Output file (String)
# 2: Temprary dir (String)
#
# Code: Yes
# Echo: No
packSources() {
  local output tmp_dir arch_name arch_ext

  output="$1"
  tmp_dir="$2"

  arch_name=$(getArchName "$output")
  arch_ext=$(getArchExt "$output")

  showm "Packing sources... " $BOLD

  pushd "${tmp_dir}" &> /dev/null

    if [[ "$arch_ext" == "tar.gz" || "$arch_ext" == "tgz" ]] ; then 
      if ! execCmd "tar" "czfv" "${arch_name}.${arch_ext}" "$arch_name" ; then
        show "Can't pack sources" $RED
        return 1
      fi
    elif [[ "$arch_ext" == "tar.bz2" || "$arch_ext" == "tbz2" || "$arch_ext" == "tar.bz" || "$arch_ext" == "tbz" ]] ; then
      if ! execCmd "tar" "cjfv" "${arch_name}.${arch_ext}" "$arch_name" ; then
        show "Can't pack sources" $RED
        return 1
      fi   
    else
      show "ERROR" $RED
      show "\nUnknown archive type" $RED
      return 1
    fi

  popd &> /dev/null

  return 0
}

# Generate output file name
#
# 1: Path (String)
#
# Code: No
# Echo: File name (String)
getOutputName() {
  local path base

  path="$1"
  base=$(basename "$path")

  if [[ -n "$version" ]] ; then
    echo "$base-$version.tar.bz2"
  else
    echo "$base.tar.bz2"
  fi
}

# Get archive name (without extension)
#
# 1: Archive name (String)
#
# Code: No
# Echo: Archive name without extension (String)
getArchName() {
  local file_name arch_type

  file_name=$(basename $1)

  for arch_type in $SUPPORTED_ARCH_TYPES ; do
    file_name="${file_name/.${arch_type}/}"
  done

  echo "$file_name"
}

# Get archive extension
#
# 1: Archive name (String)
#
# Code: No
# Echo: Archive extension (String)
getArchExt() {
  local file_name arch_type

  file_name=$(basename "$1")

  for arch_type in $SUPPORTED_ARCH_TYPES ; do
    if [[ $file_name =~ $arch_type ]] ; then
      echo "$arch_type"
      return 0
    fi
  done

  echo ""
  return 1
}

# Execute some command
#
# *: Command and all arguments
#
# Code: Yes
# Echo: No
execCmd() {
  local status

  if [[ -n "$verbose" ]] ; then
    show "\n\n$SEPARATOR\n" $GREY
    $@
    status=$?
    show "\n$SEPARATOR\n" $GREY
  else
    $@ &> /dev/null
    
    status=$?

    if [[ $status -ne 0 ]] ; then
      show "ERROR" $RED
    else
      show "DONE" $GREEN
    fi
  fi

  return $status
}

# Check response status code for repo url
#
# 1: URL (String)
#
# Code: Yes
# Echo: No
httpStatusOk() {
  local url code

  url="$1"
  code=$(curl -ILs -o /dev/null "$url" -w '%{http_code}')

  if [[ $code -ne 200 ]] ; then
    return 1
  fi

  return 0
}

# Clean temporary data and exit with given exit code
#
# 1: Path to temporary dir (String)
# 2: Exit code (Number) [Optional]
#
# Code: No
# Echo: No
cleanAndExit() {
  local tmp_dir="$1"
  local code="${2:-0}"

  rm -rf "$tmp_dir"

  exit "$code"
}

########################################################################################

# Print message to console
#
# 1: Message (String)
# 2: Color (Number) [Optional]
#
# Code: No
# Echo: No
show() {
  if [[ -n "$2" && -z "$no_colors" ]] ; then
    echo -e "\e[${2}m${1}\e[0m"
  else
    echo -e "$*"
  fi
}

# Print message without new line symbol to console
#
# 1: Message (String)
# 2: Color (Number) [Optional]
#
# Code: No
# Echo: No
showm() {
  if [[ -n "$2" && -z "$no_colors" ]] ; then
    echo -e -n "\e[${2}m${1}\e[0m"
  else
    echo -e -n "$*"
  fi
}

# Show usage info
#
# Code: No
# Echo: No
usage() {
  show ""
  show "${CL_BOLD}Usage:${CL_NORM} gopack ${CL_GREEN}{options}${CL_NORM} package-path"
  show ""
  show "Options" $BOLD
  show ""
  if [[ -n "$DARK" ]] ; then
    show "  ${CL_GREEN}--output, -o${CL_NORM} ${CL_GREY}filename${CL_NORM} ${CL_DARK}....${CL_NORM} Output file name"
    show "  ${CL_GREEN}--version, -v${CL_NORM} ${CL_GREY}version${CL_NORM} ${CL_DARK}....${CL_NORM} Package version"
    show "  ${CL_GREEN}--revision, -r${CL_NORM} ${CL_GREY}revision${CL_NORM} ${CL_DARK}..${CL_NORM} Target revision ${CL_DARK}(will be set after sources fetching)${CL_NORM}"
    show "  ${CL_GREEN}--branch, -b${CL_NORM} ${CL_GREY}branch${CL_NORM} ${CL_DARK}......${CL_NORM} Target branch ${CL_DARK}(will be set after sources fetching)${CL_NORM}"
    show "  ${CL_GREEN}--tag, -t${CL_NORM} ${CL_GREY}tag${CL_NORM} ${CL_DARK}............${CL_NORM} Target tag ${CL_DARK}(will be set after sources fetching)${CL_NORM}"
    show "  ${CL_GREEN}--tmp, -T${CL_NORM} ${CL_GREY}path${CL_NORM} ${CL_DARK}...........${CL_NORM} Path to temporary directory ${CL_DARK}(/tmp by default)${CL_NORM}"
    show "  ${CL_GREEN}--verbose, -V${CL_NORM} ${CL_DARK}............${CL_NORM} Verbose output"
    show "  ${CL_GREEN}--about${CL_NORM} ${CL_DARK}..................${CL_NORM} Show information about version"
    show "  ${CL_GREEN}--help, -h${CL_NORM} ${CL_DARK}...............${CL_NORM} Show this help message"
  else
    show "  --output, -o filename      Output file name"
    show "  --version, -v version      Package version"
    show "  --revision, -r revision    Target revision (will be set after sources fetching)"
    show "  --branch, -b branch        Target branch (will be set after sources fetching)"
    show "  --tag, -t tag              Target tag (will be set after sources fetching)"
    show "  --tmp, -T path             Path to temporary directory (/tmp by default)"
    show "  --verbose, -V              Verbose output"
    show "  --about                    Show information about version"
    show "  --help, -h                 Show this help message"
  fi
  show ""
  show "Examples" $BOLD
  show ""
  show "  gopack -v 1.0.1 github.com/essentialkaos/ssllabs_client"
  show "  Pack sources for version 1.0.1 and save result as ssllabs_client-1.0.1.tar.bz2" $DARK
  show ""
  show "  gopack -o ssllabs-client-1.0.1.tar.bz2 github.com/essentialkaos/ssllabs_client"
  show "  Pack sources for version 1.0.1 and save result as ssllabs-client-1.0.1.tar.bz2" $DARK
  show ""
  show "  gopack -o ssllabs-client-1.0.1.tgz -t v1.0.1 github.com/essentialkaos/ssllabs_client"
  show "  Fetch sources with tag v1.0.1, pack sources for version 1.0.1 and save result " $DARK
  show "  as ssllabs-client-1.0.1.tgz" $DARK
  show ""
}

about() {
  show ""
  show "${CL_BL_CYAN}$APP${CL_NORM} ${CL_CYAN}$VER${CL_NORM} - Simple tool for packing golang packages sources with all dependencies"
  show ""
  show "Copyright (C) 2009-2016 ESSENTIAL KAOS" $DARK
  show "Essential Kaos Open Source License <http://essentialkaos.com/ekol>" $DARK
  show ""
}

# Print message about unsupported argument
#
# 1: Argument (String)
#
# Code: No
# Echo: No
showArgWarn() {
  show "Unknown argument $1." $RED
  exit 1
}

## ARGUMENTS PARSING 2 #################################################################

[[ $# -eq 0 ]] && main && exit $?

unset arg argn argm argv argt argk

argv="$*" ; argt=""

while [[ -n "$1" ]] ; do
  if [[ "$1" =~ \  && -n "$argn" ]] ; then
    declare "$argn=$1"

    unset argn && shift && continue
  elif [[ $1 =~ ^-{1}[a-zA-Z0-9]{1,2}+.*$ ]] ; then
    argm=${1:1}

    if [[ \ $SHORT_ARGS\  =~ \ $argm:!?([a-zA-Z0-9_]*) ]] ; then
      arg="${BASH_REMATCH[1]}"
    else
      showArgWarn "-$argm" 2> /dev/null || :
      shift && continue
    fi

    if [[ -z "$argn" ]] ; then
      argn=$arg
    else
      [[ -z "$argk" ]] && ( showArgValWarn "--$argn" 2> /dev/null || : ) || declare "$argn=true"
      argn=$arg
    fi

    if [[ ! $SUPPORTED_ARGS\  =~ !?$argn\  ]] ; then
      showArgWarn "-$argm" 2> /dev/null || :
      shift && continue
    fi

    if [[ ${BASH_REMATCH[0]:0:1} == "!" ]] ; then
      declare "$argn=true" ; unset argn ; argk=true
    else
      unset argk
    fi

    shift && continue
  elif [[ "$1" =~ ^-{2}[a-zA-Z]{1}[a-zA-Z0-9_-]+.*$ ]] ; then
    arg=${1:2}

    if [[ $arg == *=* ]] ; then
      IFS="=" read -ra arg <<< "$arg"

      argm="${arg[0]}" ; argm=${argm//-/_}

      if [[ ! $SUPPORTED_ARGS\  =~ $argm\  ]] ; then
        showArgWarn "--${arg[0]//_/-}" 2> /dev/null || :
        shift && continue
      fi

      [[ -n "${!argm}" && $MERGEABLE_ARGS\  =~ $argm\  ]] && declare "$argm=${!argm} ${arg[@]:1:99}" || declare "$argm=${arg[@]:1:99}"

      unset argm && shift && continue
    else
      arg=${arg//-/_}

      if [[ -z "$argn" ]] ; then
        argn=$arg
      else
        [[ -z "$argk" ]] && ( showArgValWarn "--$argn" 2> /dev/null || : ) || declare "$argn=true"
        argn=$arg
      fi

      if [[ ! $SUPPORTED_ARGS\  =~ !?$argn\  ]] ; then
        showArgWarn "--${argn//_/-}" 2> /dev/null || :
        shift && continue
      fi

      if [[ ${BASH_REMATCH[0]:0:1} == "!" ]] ; then
        declare "$argn=true" ; unset argn ; argk=true
      else
        unset argk
      fi

      shift && continue
    fi
  else
    if [[ -n "$argn" ]] ; then
      [[ -n "${!argn}" && $MERGEABLE_ARGS\  =~ $argn\  ]] && declare "$argn=${!argn} $1" || declare "$argn=$1"

      unset argn && shift && continue
    fi
  fi

  argt="$argt $1" ; shift

done

[[ -n "$argn" ]] && declare "$argn=true"

unset arg argn argm argk

[[ -n "$KEEP_ARGS" ]] && main $argv || main ${argt:1:9999}

########################################################################################
